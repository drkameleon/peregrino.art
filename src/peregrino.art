;===============================================
; Peregrino.art
;
; Lightning-fast command-line 
; benchmarking tool & library
; for Arturo
;
; MIT License
; (c) 2024 Yanis Zafirópulos
;-----------------------------------------------
; @file src/peregrino.art
;===============================================
;; app:         « peregrino
;; version:     « 0.0.1
;; description: « Lightning-fast command-line benchmarking tool & library
;; arguments: [
;;     command: « A command you want to benchmark
;; ]
;==============================================================================

;import {progressive}
import ./{../../progressive.art/src/progressive}

import ./{helpers/misc}
import ./{helpers/stats}
import ./{helpers/strings}
import ./{helpers/styles}!

define :peregrino [
    init: method [commands][
        \commands: commands
        \stats: #[]
        \columns: @[
            #[header:"Command"      short:"Command"     format:{|row\cmd| (*)}]
            #[header:"Average"      short:"Avg"         format:{|row\data\avg|}]
            #[header:"Comparison"   short:"Cmp"         format:{+ |row\data\rel|%}]
            #[header:"Deviation"    short:"Dev"         format:{± |row\data\dev|}]
            #[header:"Range"        short:"Range"       format:{|row\data\min| .. |row\data\max|}]
        ]
        \ascii?: not? null? attr 'ascii
        \colorless?: not? null? attr 'colorless

        \T: (\ascii?) ? -> _tbl\ascii -> _tbl\normal
        \E: (\ascii?) ? -> _elements\ascii -> _elements\normal
    ]

    colored: method [col,str][
        (\colorless?) ? -> str -> color col str
    ]

    printInfo: function [][
        print ""
        print [\colored.bold #magenta "   Peregrino" ~"v/|script\version|"]
        print ""
        print [\colored.bold #gray pad.right "   System :" 10 \colored #gray ~"|sys\cpu\arch|/|sys\os|"]
        print [\colored.bold #gray pad.right "   CPU    :" 10 \colored #gray to :string sys\cpu\cores \colored #gray "cores"]
    ]

    printHeader: method [title][
        print ""
        print \colored #orange repeat \E\horLine terminal\width
        print \colored.bold #orange " " ++ \E\dot ++ " " ++ upper title
        print ""
    ]

    getColumns: method [][
        minNeeded: 0
        minFirstColumn: 25
        columns: new \columns
        loop drop columns 'col [
            col\min: max @[size col\header, max map \final 'row ->
                size ~ col\format
            ]
            minNeeded: minNeeded + col\min + 2
        ]
        minNeeded: minNeeded + 
                    2 +  ; spaces front/back
                    6    ; line separators

        spaceLeft: terminal\width - minNeeded
        columns\0\min: spaceLeft - 2

        if columns\0\min < minFirstColumn [
            lastCol: pop 'columns
            columns\0\min: spaceLeft + (lastCol\min + 1)
        ]

        adjust: 2
        do.times: 2 [
            c: 1
            while [and? c < size columns columns\0\min >= minFirstColumn + adjust][
                columns\[c]\min: columns\[c]\min + adjust
                columns\0\min: columns\0\min - adjust
                c: c + 1
            ]
        ]

        return columns
    ]

    finalizeData: method [][
        stats: map \stats [k, v] -> extend getStats v #[cmd: k]
        bestAvg: min map stats 'v -> v\data\avg
        loop stats 'v [
            v\data\rel: 100 * (v\data\avg - bestAvg) / bestAvg
        ]

        stats: arrange stats 'stat -> stat\data\avg

        \final: map stats 'v [
            #[
                cmd: v\cmd
                data: #.raw flatten map v\data [kk,vv]->
                    @[kk, nicefloat vv]
                outliers?: v\outliers?
            ]
        ]
    ]

    showAnalysis: method [][
        \printHeader "analysis"

        \finalizeData
        cols: \getColumns
 
        print 
            "  " ++ (spacer cols\0\min + 2) ++
            \T\topLeft ++ 
            (join.with:\T\tTop map drop cols 'c ->
                repeat \T\horLine c\min + 2) ++
            \T\topRight
        
        print "   " ++ (join.with:\T\verLine map.with:'i cols 'c [
                (i=0)? -> pad.right c\header c\min + 1
                       -> pad.center c\header c\min + 2
            ]) ++ \T\verLine

        print " " ++ \T\topLeft ++ (join.with:\T\cross map cols 'c ->
            repeat \T\horLine c\min + 2) ++
            \T\tRight

        loop.with:'rowId \final 'row [
            print " " ++ \T\verLine ++ " " ++ (
                join.with:\T\verLine map.with:'i cols 'c [
                    str: switch i=0 [
                        (pad.right replace ~ c\format "(*)" "" c\min + 1 - (row\outliers? ? -> 4 -> 0)) ++
                            (row\outliers? ? -> \colored #gray "(*) " -> "")
                    ][
                        choose c\header [
                            "Deviation" [
                                \colored #gray pad.center ~ c\format c\min + 2
                            ]
                            "Comparison" [
                                ("+ 0.00%" = ~ c\format) ?
                                    -> pad.center "--" c\min + 2
                                    -> pad.center ~ c\format c\min + 2
                            ]
                            else [
                                pad.center ~ c\format c\min + 2
                            ]
                        ]
                    ]
                    (rowId = 0)? -> \colored #green str
                                 -> str
                ]
            ) ++ \T\verLine
        ]

        print " " ++ \T\bottomLeft ++ (join.with:\T\tBottom map cols 'c ->
            repeat \T\horLine c\min + 2) ++
            \T\bottomRight

        if some? \final 'f -> f\outliers? [
            print \colored #gray "  (*) " ++ fillEvenly "Detected statistically-significant outliers! You could try running this test again after lowering your system load, in order to to minimize any interference to the results." 6
        ]
        print ""
    ]

    calibrate: function [cmd][
        calvalues: []
        timeForOne: 0.001
        if \ascii? -> do [.plain]
        if \colorless? -> do [.colorless]
        progressive\loop .hide .ratioless .label: pad.right "Calibrating:" 20 10 'x [
            (x < 10)?[ 
                pause 50
                'calvalues ++ scalar benchmark.get [
                    output: execute ""
                ]
            ][
                'calvalues ++ to :floating scalar benchmark.get [
                    output: execute cmd
                ]  
            ]
        ]
        prints repeat "\b \b" terminal\width
        return @[to :floating (sum first.n:9 calvalues)/9, last calvalues]
    ]

    benchmark: method [times][
        \printInfo
        \printHeader "benchmarks"

        minimumRunningTime: 1000

        loop \commands 'command [
            
            \stats\[command]: []
            [calibrator, timeForOne]: \calibrate command

            if zero? calculatedTimes: <= minimumRunningTime / to :integer timeForOne ->
                calculatedTimes: 3

            runs: times ?? calculatedTimes
            
            if \ascii? -> do [.plain]
            if \colorless? -> do [.colorless]
            bar: progressive\new.keep .label:pad.right "Benchmarking:" 20 runs!
            bar\processing: command
            bar\increase 0
            loop runs 'x [
                \stats\[command]: \stats\[command] ++ (benchmark.get [
                    output: execute command
                ])
                if x = runs [
                    estimate: nicefloat average map \stats\[command] => scalar
                    bar\message: command
                    bar\label: (pad.right ~"~ |estimate|/run" 17) ++ pad.right \E\timer 3
                ]
                bar\increase 1
            ]
            \stats\[command]: map \stats\[command] 'v -> to :floating (scalar v) - calibrator
            prints repeat "\b" terminal\width
            prints "\n"
        ]

        \showAnalysis
    ]
]

peregrino: function [cmds][
    p: to :peregrino [cmds]!
    p\benchmark ø
]

;---------------------------
; The main entry point
;---------------------------

if standalone? [
    import ./{helpers/cmdline}

    ; Helper functions

    getCommands: function [][
        inputs: optValues
        if optFile [
            inputs: []
            loop optValues 'optV [
                inputs: inputs ++ read.lines optV
            ]
        ]
        
        (not? empty? optParams)? [
            d: # to :block optParams
            dicts: map product.cartesian map couple keys d values d 'coup [
                (block? last coup)?[
                    map last coup 'item -> @[first coup, item]
                ][
                    @[coup]
                ]
            ] 'dic -> dictionary.raw flatten dic

            flatten unique map dicts 'dic [
                export dic
                map inputs 'val -> 
                    render val
            ]
        ][
            inputs
        ]
    ]

    ; the main process

    cmd: to :cmdline #[
        information: script
        options: @[
            @["r" "run"         [:integer] "times"  "Specify number of times to run each command"   ø]
            @["f" "file"        [:logical] ""       "Read commands from text file (one per line)"   false]
            @["p" "params"      [:string]  "string" "Use custom params in command"                  ""]
            ø
            @["a" "ascii"       [:logical] ""       "Use simple style, with ASCII-only characters"  false]
            @["c" "colorless"   [:logical] ""       "Don't use colored output"                      false]
        ]
    ]!
    export cmd\processing args

    if optAscii -> do [.ascii]
    if optColorless -> do [.colorless]

    pr: to :peregrino @[getCommands]!
    pr\benchmark optRun
]